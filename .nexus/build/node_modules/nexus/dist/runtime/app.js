"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.createAppState = void 0;
const tslib_1 = require("tslib");
const Logger = tslib_1.__importStar(require("@nexus/logger"));
const nexus_logger_1 = require("../lib/nexus-logger");
const Plugin = tslib_1.__importStar(require("../lib/plugin"));
const Reflection = tslib_1.__importStar(require("../lib/reflection/stage"));
const Schema = tslib_1.__importStar(require("./schema"));
const Server = tslib_1.__importStar(require("./server"));
const Settings = tslib_1.__importStar(require("./settings"));
const utils_1 = require("./utils");
const scalars_1 = require("../lib/scalars");
const log = Logger.log.child('app');
/**
 * Create new app state. Be careful to pass this state to components to complete its
 * data. The data returned only contains core state, despite what the return
 * type says.
 */
function createAppState() {
    const appState = {
        assembled: null,
        running: false,
        plugins: [],
    };
    return appState;
}
exports.createAppState = createAppState;
/**
 * Create an app instance
 */
function create() {
    const appState = createAppState();
    const serverComponent = Server.create(appState);
    const schemaComponent = Schema.create(appState);
    const settingsComponent = Settings.create(appState, {
        serverSettings: serverComponent.private.settings,
        schemaSettings: schemaComponent.private.settings,
        log: Logger.log,
    });
    const app = {
        log: log,
        settings: settingsComponent.public,
        schema: schemaComponent.public,
        server: serverComponent.public,
        reset() {
            // todo once we have log filtering, make this debug level
            nexus_logger_1.rootLogger.trace('resetting state');
            schemaComponent.private.reset();
            serverComponent.private.reset();
            settingsComponent.private.reset();
            appState.assembled = null;
            appState.plugins = [];
            appState.running = false;
        },
        assemble() {
            if (appState.assembled)
                return;
            schemaComponent.private.beforeAssembly();
            /**
             * Plugin reflection is run in the same process (eval). This means if the
             * process is the app, which it is during testing for example, then we
             * need to take extreme care to not mark assembly as complete, during
             * plugin reflection. If we did, then, when we would try to start the app,
             * it would think it is already assembled. !
             */
            if (Reflection.isReflectionStage('plugin'))
                return;
            appState.assembled = {};
            const loadedPlugins = Plugin.importAndLoadRuntimePlugins(appState.plugins, appState.schemaComponent.scalars);
            appState.assembled.loadedPlugins = loadedPlugins;
            const { schema, missingTypes } = schemaComponent.private.assemble(loadedPlugins);
            appState.assembled.schema = schema;
            appState.assembled.missingTypes = missingTypes;
            if (Reflection.isReflectionStage('typegen'))
                return;
            const { createContext } = serverComponent.private.assemble(loadedPlugins, schema);
            appState.assembled.createContext = createContext;
            const { settings } = settingsComponent.private.assemble();
            appState.assembled.settings = settings;
            schemaComponent.private.checks();
        },
        async start() {
            if (Reflection.isReflection())
                return;
            if (appState.running)
                return;
            await serverComponent.private.start();
            appState.running = true;
        },
        async stop() {
            if (Reflection.isReflection())
                return;
            if (!appState.running)
                return;
            await serverComponent.private.stop();
            appState.running = false;
        },
        use(plugin) {
            utils_1.assertAppNotAssembled(appState, 'app.use', 'The plugin you attempted to use will be ignored');
            appState.plugins.push(plugin);
        },
    };
    /**
     * Setup default log filter
     */
    app.settings.change({
        logger: {
            filter: 'app:*, nexus:*@info+, *@warn+',
        },
    });
    /**
     * Setup default scalar types
     */
    app.schema.importType(scalars_1.builtinScalars.DateTime, 'date');
    app.schema.importType(scalars_1.builtinScalars.Json, 'json');
    return Object.assign(Object.assign({}, app), { private: {
            state: appState,
        } });
}
exports.create = create;
//# sourceMappingURL=app.js.map