"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.defaultState = void 0;
const tslib_1 = require("tslib");
const express_1 = tslib_1.__importDefault(require("express"));
const HTTP = tslib_1.__importStar(require("http"));
const strip_ansi_1 = tslib_1.__importDefault(require("strip-ansi"));
const utils_1 = require("../../lib/utils");
const DevMode = tslib_1.__importStar(require("../dev-mode"));
const utils_2 = require("../utils");
const handler_graphql_1 = require("./handler-graphql");
const handler_playground_1 = require("./handler-playground");
const logger_1 = require("./logger");
const settings_1 = require("./settings");
const resolverLogger = logger_1.log.child('graphql');
exports.defaultState = {
    running: false,
    httpServer: HTTP.createServer(),
    createContext: null,
};
function create(appState) {
    const settings = settings_1.createServerSettingsManager();
    const express = express_1.default();
    const state = Object.assign({}, exports.defaultState);
    const api = {
        raw: {
            http: state.httpServer,
        },
        express,
        handlers: {
            get playground() {
                var _a;
                return ((_a = utils_2.assembledGuard(appState, 'app.server.handlers.playground', () => {
                    // todo should be accessing settings from assembled app state settings
                    return wrapHandlerWithErrorHandling(handler_playground_1.createRequestHandlerPlayground({ graphqlEndpoint: settings.data.path }));
                })) !== null && _a !== void 0 ? _a : utils_1.noop);
            },
            get graphql() {
                var _a;
                return ((_a = utils_2.assembledGuard(appState, 'app.server.handlers.graphql', () => {
                    return wrapHandlerWithErrorHandling(handler_graphql_1.createRequestHandlerGraphQL(appState.assembled.schema, appState.assembled.createContext));
                })) !== null && _a !== void 0 ? _a : utils_1.noop);
            },
        },
    };
    const internalServer = {
        private: {
            settings,
            state,
            reset() {
                internalServer.private.state = Object.assign({}, exports.defaultState);
            },
            assemble(loadedRuntimePlugins, schema) {
                state.httpServer.on('request', express);
                if (settings.data.playground) {
                    express.get(settings.data.playground.path, wrapHandlerWithErrorHandling(handler_playground_1.createRequestHandlerPlayground({ graphqlEndpoint: settings.data.path })));
                }
                const createContext = createContextCreator(appState.schemaComponent.contextContributors, loadedRuntimePlugins);
                const graphqlHandler = handler_graphql_1.createRequestHandlerGraphQL(schema, createContext);
                express.post(settings.data.path, wrapHandlerWithErrorHandling(graphqlHandler));
                express.get(settings.data.path, wrapHandlerWithErrorHandling(graphqlHandler));
                return { createContext };
            },
            async start() {
                await utils_1.httpListen(state.httpServer, { port: settings.data.port, host: settings.data.host });
                state.running = true;
                // About !
                // 1. We do not support listening on unix domain sockets so string
                //    value will never be present here.
                // 2. We are working within the listen callback so address will not be null
                const address = state.httpServer.address();
                settings.data.startMessage({
                    port: address.port,
                    host: address.address,
                    ip: address.address,
                    path: settings.data.path,
                    playgroundPath: settings.data.playground ? settings.data.playground.path : undefined,
                });
                DevMode.sendServerReadySignalToDevModeMaster();
            },
            async stop() {
                if (!state.running) {
                    logger_1.log.warn('You called `server.stop` but the server was not running.');
                    return Promise.resolve();
                }
                await utils_1.httpClose(state.httpServer);
                state.running = false;
            },
        },
        public: api,
    };
    return internalServer;
}
exports.create = create;
/**
 * Log http errors during development.
 */
const wrapHandlerWithErrorHandling = (handler) => {
    return async (req, res) => {
        var _a;
        await handler(req, res);
        if (res.statusCode !== 200 && res.error) {
            const error = res.error;
            const colorlessMessage = strip_ansi_1.default(error.message);
            if (process.env.NEXUS_STAGE === 'dev') {
                resolverLogger.error((_a = error.stack) !== null && _a !== void 0 ? _a : error.message);
            }
            else {
                resolverLogger.error('An exception occured in one of your resolver', {
                    error: error.stack ? strip_ansi_1.default(error.stack) : colorlessMessage,
                });
            }
            // todo bring back payload sanitization for data sent to clients
            // error.message = colorlessMessage
        }
    };
};
/**
 * Combine all the context contributions defined in the app and in plugins.
 */
function createContextCreator(contextContributors, plugins) {
    const createContext = async (req) => {
        let context = {};
        // Integrate context from plugins
        for (const plugin of plugins) {
            if (!plugin.context)
                continue;
            const contextContribution = await plugin.context.create(req);
            Object.assign(context, contextContribution);
        }
        // Integrate context from app context api
        // TODO good runtime feedback to user if something goes wrong
        for (const contextContributor of contextContributors) {
            const contextContribution = await contextContributor(req);
            Object.assign(context, contextContribution);
        }
        Object.assign(context, { log: logger_1.log.child('request') });
        return context;
    };
    return createContext;
}
//# sourceMappingURL=server.js.map