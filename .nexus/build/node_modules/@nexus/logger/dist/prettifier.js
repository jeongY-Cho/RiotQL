"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = exports.separators = void 0;
const tslib_1 = require("tslib");
const strip_ansi_1 = tslib_1.__importDefault(require("strip-ansi"));
const util = tslib_1.__importStar(require("util"));
const chalk_1 = require("./chalk");
const Level = tslib_1.__importStar(require("./level"));
const utils = tslib_1.__importStar(require("./utils"));
const stopWatch = createStopWatch();
// Helpful unicode pickers:
// - https://jrgraphix.net/r/Unicode/2600-26FF
// - https://graphemica.com/
const LEVEL_STYLES = {
    fatal: {
        // badge: '⚰',
        // badge: '☠',
        badge: '✕',
        color: chalk_1.chalk.red,
    },
    error: {
        badge: '■',
        color: chalk_1.chalk.red,
    },
    warn: {
        badge: '▲',
        color: chalk_1.chalk.yellow,
    },
    info: {
        // badge: '↣',
        badge: '●',
        color: chalk_1.chalk.green,
    },
    debug: {
        // badge: '◒',
        badge: '○',
        // badge: '⚒',
        // badge: '↺',
        // badge: '↯',
        // badge: '⟐',
        color: chalk_1.chalk.blue,
    },
    trace: {
        badge: '—',
        // badge: '~',
        // badge: '⟣',
        // badge: '⟛',
        // badge: '⠿',
        color: chalk_1.chalk.magenta,
    },
};
exports.separators = {
    path: {
        symbol: ':',
    },
    event: {
        symbol: ' ',
    },
    context: {
        singleLine: {
            symbol: '  --  ',
            // context = ` ${chalk.gray('⸬')}  ` + context
            // context = ` ${chalk.gray('•')}  ` + context
            // context = ` ${chalk.gray('⑊')}  ` + context
            // context = ` ${chalk.gray('//')}  ` + context
            // context = ` ${chalk.gray('—')}  ` + context
            // context = ` ${chalk.gray('~')}  ` + context
            // context = ` ${chalk.gray('⌀')}  ` + context
            // context = ` ${chalk.gray('——')}  ` + context
            // context = ` ${chalk.gray('❯')}  ` + context
            // context = ` ${chalk.gray('->')}  ` + context
            // context = ` ${chalk.gray('⌁')}  ` + context
            // context = ` ${chalk.gray('⋯')}  ` + context
            // context = ` ${chalk.gray('⌁')}  ` + context
            // context = ` ${chalk.gray('⟛')}  ` + context
            color: chalk_1.chalk.gray,
        },
        multiline: {
            symbol: '',
        },
    },
    contextKeyVal: {
        singleLine: {
            symbol: ': ',
            color: chalk_1.chalk.gray,
        },
        multiline: {
            symbol: '  ',
        },
    },
    contextEntry: {
        singleLine: '  ',
        multiline: (gutterSpace) => ({
            symbol: gutterSpace + `| `,
            color: chalk_1.chalk.gray,
        }),
    },
};
function render(opts, logRecord) {
    var _a, _b, _c;
    const terminalWidth = (_a = process.stdout.columns) !== null && _a !== void 0 ? _a : 80;
    const levelLabel = Level.LEVELS_BY_NUM[logRecord.level].label;
    const style = LEVEL_STYLES[levelLabel];
    //
    // render time diff
    //
    let timeDiff = '';
    let timeDiffRendered = '';
    if (opts.timeDiff) {
        let elapsedTime = stopWatch.lap();
        let unit;
        // <10s
        if (elapsedTime < 1000 * 10) {
            unit = 'ms';
            // 10s-100s (exclusive)
        }
        else if (elapsedTime >= 1000 * 10 && elapsedTime < 1000 * 100) {
            elapsedTime = Math.round(elapsedTime / 1000);
            unit = 's';
            // 100s-60m (exclusive)
        }
        else if (elapsedTime >= 1000 * 100 && elapsedTime < 1000 * 60 * 60) {
            elapsedTime = Math.round(elapsedTime / 1000 / 60);
            unit = 'm';
            // 1h-24h (exclusive)
        }
        else if (elapsedTime >= 1000 * 60 * 60 && elapsedTime < 1000 * 60 * 60 * 24) {
            elapsedTime = Math.round(elapsedTime / 1000 / 60 / 60);
            unit = 'h';
            // 1d-999d (exclusive)
        }
        else if (elapsedTime >= 1000 * 60 * 60 && elapsedTime < 1000 * 60 * 60 * 24) {
            elapsedTime = Math.round(elapsedTime / 1000 / 60 / 60 / 24);
            unit = 'd';
        }
        else {
            unit = 'max';
        }
        if (unit === 'ms') {
            timeDiff = `${utils.spanSpaceRight(4, String(elapsedTime))} `;
        }
        else if (unit === 'max') {
            timeDiff = ' ∞ ';
        }
        else {
            timeDiff = `${unit} ${utils.spanSpaceRight(2, String(elapsedTime))} `;
        }
        timeDiffRendered = chalk_1.chalk.gray(timeDiff);
    }
    //
    // render gutter
    //
    const levelLabelSized = opts.levelLabel ? ' ' + utils.clampSpace(5, levelLabel) + ' ' : ' ';
    const gutterRendered = `${timeDiffRendered}${style.color(`${style.badge}${levelLabelSized}`)}`;
    // pre-emptyive measurement for potential multiline context indentation later on
    const gutterWidth = timeDiff.length + style.badge.length + levelLabelSized.length;
    /**
     * Render Pre-Context
     *
     * Path is null when log came from root.
     */
    const path = (_c = (_b = logRecord.path) === null || _b === void 0 ? void 0 : _b.join(renderEl(exports.separators.path))) !== null && _c !== void 0 ? _c : '';
    const preContextWidth = path
        ? path.length + exports.separators.event.symbol.length + logRecord.event.length
        : logRecord.event.length;
    const preContextRendered = path
        ? style.color(path) + renderEl(exports.separators.event) + logRecord.event
        : logRecord.event;
    //
    // render context
    //
    // Factor in:
    // 1. the headers section
    // 2. the headers/context separator
    const availableSinglelineContextColumns = terminalWidth - gutterWidth - preContextWidth - exports.separators.context.singleLine.symbol.length;
    let contextColumnsConsumed = 0;
    const contextEntries = logRecord.context ? Object.entries(logRecord.context) : [];
    let widestKey = 0;
    let first = true;
    const contextEntriesRendered = contextEntries.map(([key, value]) => {
        // Track context space consumption of entry separators
        if (!first)
            contextColumnsConsumed += exports.separators.contextEntry.singleLine.length;
        else
            first = false;
        // Track widest key optimistically for use in multiline layout later
        if (key.length > widestKey)
            widestKey = key.length;
        contextColumnsConsumed += key.length + exports.separators.contextKeyVal.singleLine.symbol.length;
        const valueRendered = `${util.inspect(value, {
            breakLength: availableSinglelineContextColumns,
            colors: opts.color,
            getters: true,
            depth: 20,
        })}`;
        // todo probably not cheap, calculate instead by running a context columns consumed tally
        // this is also the only use-case for stripAnsi and then we can drop the dep
        contextColumnsConsumed += strip_ansi_1.default(valueRendered).length;
        return [key, valueRendered];
    });
    const contextFitsSingleLine = contextColumnsConsumed <= availableSinglelineContextColumns;
    let contextRendered = '';
    if (contextEntries.length > 0) {
        if (contextFitsSingleLine) {
            contextRendered =
                renderEl(exports.separators.context.singleLine) +
                    contextEntriesRendered
                        .map(([key, value]) => `${chalk_1.chalk.gray(key)}${renderEl(exports.separators.contextKeyVal.singleLine)}${value}`)
                        .join(exports.separators.contextEntry.singleLine);
        }
        else {
            const spineRendered = renderEl(exports.separators.contextEntry.multiline(utils.spanSpace(gutterWidth)));
            contextRendered =
                renderEl(exports.separators.context.multiline) +
                    '\n' +
                    spineRendered +
                    contextEntriesRendered
                        .map(([key, value]) => `${chalk_1.chalk.gray(utils.clampSpace(widestKey, key))}${renderEl(exports.separators.contextKeyVal.multiline)}${formatBlock(value, {
                        leftSpineSymbol: spineRendered,
                        excludeFirstLine: true,
                        indent: widestKey + exports.separators.contextKeyVal.multiline.symbol.length,
                    })}`)
                        .join('\n' + spineRendered);
        }
    }
    //
    // put it together
    //
    return `${gutterRendered}${preContextRendered}${contextRendered}`;
}
exports.render = render;
function renderEl(el) {
    return el.color ? el.color(el.symbol) : el.symbol;
}
/**
 * Given a multiline string, run a single pass over each line carrying out the
 * given transformations configured in given options.
 *
 * If singleline given, returned as-is.
 */
function formatBlock(block, opts) {
    var _a, _b, _c, _d, _e;
    const [first, ...rest] = block.split('\n');
    if (rest.length === 0)
        return first;
    const linesToProcess = opts.excludeFirstLine === true ? rest : (rest.unshift(first), rest);
    const prefix = typeof opts.leftSpineSymbol === 'string' ? opts.leftSpineSymbol : (_b = (_a = opts.leftSpineSymbol) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : '';
    const indent = opts.indent !== undefined ? utils.spanSpace(opts.indent) : '';
    const linesProcessed = opts.excludeFirstLine === true ? [first] : [];
    for (const line of linesToProcess) {
        const prefixRendered = typeof opts.leftSpineSymbol === 'object' ? (_e = (_d = (_c = opts.leftSpineSymbol) === null || _c === void 0 ? void 0 : _c.color) === null || _d === void 0 ? void 0 : _d.call(_c, prefix)) !== null && _e !== void 0 ? _e : prefix : prefix;
        linesProcessed.push(prefixRendered + indent + line);
    }
    return linesProcessed.join('\n');
}
/**
 * Create a stop watch. Makes it simple to calculate elapsed time on every
 * invocation of `lap`.
 */
function createStopWatch() {
    let prev = Date.now();
    return {
        lap() {
            const curr = Date.now();
            const elapsed = curr - prev;
            prev = curr;
            return elapsed;
        },
    };
}
//# sourceMappingURL=prettifier.js.map