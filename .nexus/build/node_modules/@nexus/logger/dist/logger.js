"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = void 0;
const tslib_1 = require("tslib");
const Lo = tslib_1.__importStar(require("lodash"));
const OS = tslib_1.__importStar(require("os"));
const data_1 = require("./data");
const Filter = tslib_1.__importStar(require("./filter"));
const level_1 = require("./level");
const Prettifier = tslib_1.__importStar(require("./prettifier"));
/**
 * Create a logger.
 */
function create(rootState, path, parentContext) {
    if (path)
        validatePath(path);
    const state = {
        // Copy as addToContext will mutate it
        pinnedAndParentContext: parentContext ? Lo.cloneDeep(parentContext) : undefined,
        children: [],
    };
    function updateContextAndPropagate(newContext) {
        state.pinnedAndParentContext = newContext;
        state.children.forEach((child) => {
            child.onNewParentContext(state.pinnedAndParentContext);
        });
    }
    function send(levelLabel, event, localContext) {
        var _a, _b, _c;
        const level = level_1.LEVELS[levelLabel].number;
        const logRec = {
            event,
            level,
        };
        if (path)
            logRec.path = path;
        if (Filter.test(rootState.settings.filter.patterns, logRec)) {
            // Avoid mutating the passed local context
            if (localContext && state.pinnedAndParentContext) {
                logRec.context = Lo.merge({}, state.pinnedAndParentContext, localContext);
            }
            else if (localContext) {
                logRec.context = localContext;
            }
            else if (state.pinnedAndParentContext) {
                logRec.context = state.pinnedAndParentContext;
            }
            if ((_a = rootState.settings) === null || _a === void 0 ? void 0 : _a.data.hostname) {
                logRec.hostname = OS.hostname();
            }
            if ((_b = rootState.settings) === null || _b === void 0 ? void 0 : _b.data.pid) {
                logRec.pid = process.pid;
            }
            if ((_c = rootState.settings) === null || _c === void 0 ? void 0 : _c.data.time) {
                logRec.time = Date.now();
            }
            const logMsg = rootState.settings.pretty.enabled
                ? Prettifier.render(rootState.settings.pretty, logRec)
                : JSON.stringify(logRec);
            rootState.settings.output.write(logMsg + OS.EOL);
        }
    }
    const link = {
        onNewParentContext(newParentContext) {
            updateContextAndPropagate(Lo.merge(
            // Copy so that we don't mutate parent while maintaining local overrides...
            {}, newParentContext, 
            // ...this
            state.pinnedAndParentContext));
        },
    };
    const logger = {
        fatal(event, context) {
            send('fatal', event, context);
        },
        error(event, context) {
            send('error', event, context);
        },
        warn(event, context) {
            send('warn', event, context);
        },
        info(event, context) {
            send('info', event, context);
        },
        debug(event, context) {
            send('debug', event, context);
        },
        trace(event, context) {
            send('trace', event, context);
        },
        addToContext(context) {
            // Can safely mutate here, save some electricity...
            updateContextAndPropagate(Lo.merge(state.pinnedAndParentContext, context));
            return logger;
        },
        child: (name) => {
            const { logger: child, link } = create(rootState, path ? path.concat([name]) : [name], state.pinnedAndParentContext);
            state.children.push(link);
            return child;
        },
    };
    return {
        logger,
        link,
    };
}
exports.create = create;
function validatePath(path) {
    path.forEach((part) => {
        if (!data_1.validPathSegmentNameRegex.test(part)) {
            throw new Error(`Invalid logger path segment: ${part}`);
        }
    });
}
//# sourceMappingURL=logger.js.map