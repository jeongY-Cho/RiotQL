"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rightOrThrow = exports.getRight = exports.getLeft = exports.createContextualError = exports.parseFromEnvironment = exports.isEmpty = exports.last = exports.omitUndefinedKeys = exports.range = exports.constant = exports.casesHandled = exports.spanSpaceRight = exports.spanChar = exports.spanSpace = exports.clampSpace = exports.span = void 0;
const Either_1 = require("fp-ts/lib/Either");
const util_1 = require("util");
/**
 * Guarantee the length of a given string, padding before or after with the
 * given character. If the given string is longer than  the span target, then it
 * will be cropped.
 */
function span(padSide, padChar, target, content) {
    if (content.length > target) {
        return content.slice(0, target);
    }
    let toPadSize = target - content.length;
    while (toPadSize > 0) {
        if (padSide === 'padAfter') {
            content = content + padChar;
        }
        else if (padSide === 'padBefore') {
            content = padChar + content;
        }
        toPadSize--;
    }
    return content;
}
exports.span = span;
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned left and if exceeds span target length to begin with gets cropped.
 */
exports.clampSpace = span.bind(null, 'padAfter', ' ');
/**
 * Create a string of space of the given length.
 */
function spanSpace(num) {
    return spanChar(num, ' ');
}
exports.spanSpace = spanSpace;
/**
 * Create a string of the given length and character
 */
function spanChar(num, char) {
    return range(num).map(constant(char)).join('');
}
exports.spanChar = spanChar;
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned right and if exceeds span target length to begin with gets cropped.
 */
exports.spanSpaceRight = span.bind(null, 'padBefore', ' ');
/**
 * Use this to make assertion at end of if-else chain that all members of a
 * union have been accounted for.
 */
function casesHandled(x) {
    throw new Error(`A case of value was not handled: ${x}`);
}
exports.casesHandled = casesHandled;
/**
 * Create a function that will only ever return the given value when called.
 */
function constant(x) {
    return function () {
        return x;
    };
}
exports.constant = constant;
/**
 * Create a range of integers.
 */
function range(times) {
    const list = [];
    while (list.length < times) {
        list.push(list.length + 1);
    }
    return list;
}
exports.range = range;
/**
 * Strip keys from object whose value is undefined.
 */
function omitUndefinedKeys(data) {
    return Object.entries(data !== null && data !== void 0 ? data : {})
        .filter(([k, v]) => v !== undefined)
        .reduce((acc, [k, v]) => Object.assign(acc, { [k]: v }), {});
}
exports.omitUndefinedKeys = omitUndefinedKeys;
/**
 * Get the last item of an array.
 */
function last(xs) {
    return xs[xs.length - 1];
}
exports.last = last;
function isEmpty(x) {
    if (typeof x === 'string' && x === '')
        return true;
    if (x === undefined)
        return true;
    return Object.values(x).filter((val) => val !== undefined).length === 0;
}
exports.isEmpty = isEmpty;
/**
 * Run a given parser over an environment variable. If parsing fails, throw a
 * contextual error message.
 */
function parseFromEnvironment(key, parser) {
    const envVarValue = process.env[key]; // assumes env presence handled before
    const result = parser.run(envVarValue);
    if (result === null) {
        throw new Error(`Could not parse environment variable ${key} into ${parser.info.typeName}. The environment variable was: ${util_1.format(envVarValue)}. A valid environment variable must be like: ${parser.info.valid}`);
    }
    return result;
}
exports.parseFromEnvironment = parseFromEnvironment;
/**
 * Create an error with contextual data about it.
 *
 * @remarks
 *
 * This is handy with fp-ts Either<...> because, unlike try-catch, errors are
 * strongly typed with the Either contstruct, making it so the error contextual
 * data flows with inference through your program.
 */
function createContextualError(message, context) {
    const e = new Error(message);
    Object.defineProperty(e, 'message', {
        enumerable: true,
        value: e.message,
    });
    e.context = context;
    return e;
}
exports.createContextualError = createContextualError;
/**
 * Extract the left value from an Either.
 */
function getLeft(e) {
    if (Either_1.isLeft(e))
        return e.left;
    return undefined;
}
exports.getLeft = getLeft;
/**
 * Extract the right value from an Either.
 */
function getRight(e) {
    if (Either_1.isRight(e))
        return e.right;
    return undefined;
}
exports.getRight = getRight;
/**
 * Extract the right value from an Either or throw.
 */
function rightOrThrow(x) {
    if (Either_1.isLeft(x))
        throw new Error(`Failed to get right value of either type because it was actually left. The left value was:\n\n${x.left}`);
    return x.right;
}
exports.rightOrThrow = rightOrThrow;
//# sourceMappingURL=utils.js.map